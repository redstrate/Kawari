//! Obfuscation-related structures and procedures. This is based on the ever fantastic work of Perchbird and his Unscrambler: https://github.com/perchbirdd/Unscrambler
//! This is simply a Rust-reimplementation of Unscrambler.

use std::num::Wrapping;

use crate::common::CHAR_NAME_MAX_LENGTH;

/// Constant to enable packet obfuscation. Changes every patch.
pub const OBFUSCATION_ENABLED_MODE: u8 = 21;

// Helper macro so we don't repeat ourselves a bunch of times
macro_rules! scrambler_dir {
    ($rel_path:literal) => {
        concat!("../../resources/data/scrambler/", $rel_path)
    };
}

/// Generates the necessary keys from three seeds.
pub struct ScramblerKeyGenerator {
    table0: Vec<i32>,
    table1: Vec<i32>,
    table2: Vec<i32>,
    mid_table: &'static [u8],
    day_table: &'static [u8],
    opcode_key_table: Vec<i32>,
    table_radixes: &'static [i32],
    table_max: &'static [i32],
}

impl Default for ScramblerKeyGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl ScramblerKeyGenerator {
    pub fn new() -> Self {
        Self {
            table0: include_bytes!(scrambler_dir!("table0.bin"))
                .chunks(4)
                .map(|x| i32::from_le_bytes(x.try_into().unwrap()))
                .collect(),
            table1: include_bytes!(scrambler_dir!("table1.bin"))
                .chunks(4)
                .map(|x| i32::from_le_bytes(x.try_into().unwrap()))
                .collect(),
            table2: include_bytes!(scrambler_dir!("table2.bin"))
                .chunks(4)
                .map(|x| i32::from_le_bytes(x.try_into().unwrap()))
                .collect(),
            mid_table: include_bytes!(scrambler_dir!("midtable.bin")),
            day_table: include_bytes!(scrambler_dir!("daytable.bin")),
            opcode_key_table: include_bytes!(scrambler_dir!("opcodekeytable.bin"))
                .chunks(4)
                .map(|x| i32::from_le_bytes(x.try_into().unwrap()))
                .collect(),

            // TODO: is it possible to calculate these automatically?
            table_radixes: &[120, 93, 112],
            table_max: &[73, 95, 193],
        }
    }

    fn derive(&self, set: u8, n_seed_1: u8, n_seed_2: u8, epoch: u32) -> u8 {
        // FIXME: so many probably unnecessary casts here

        let mid_index = 8 * (n_seed_1 as usize % (self.mid_table.len() / 8));
        let mid_table_value = self.mid_table[4 + mid_index];
        let mut mid_bytes = [0u8; 4];
        mid_bytes.copy_from_slice(&self.mid_table[mid_index..mid_index + 4]);
        let mid_value = u32::from_le_bytes(mid_bytes);

        let epoch_days = 3 * (epoch as usize / 60 / 60 / 24);
        let day_table_index = 4 * (epoch_days % (self.day_table.len() / 4));
        let day_table_value = self.day_table[day_table_index];

        let set_radix = self.table_radixes[set as usize];
        let set_max = self.table_max[set as usize];
        let table_index = (set_radix * (n_seed_2 as i32 % set_max)) as usize
            + mid_value as usize * n_seed_1 as usize % set_radix as usize;
        let set_result = match set {
            0 => self.table0[table_index],
            1 => self.table1[table_index],
            2 => self.table2[table_index],
            _ => 0,
        };

        (n_seed_1 as i32 + mid_table_value as i32 + day_table_value as i32 + set_result) as u8
    }

    /// Generates keys for scrambling or unscrambling packets. The callee must keep track of their seeds, we only generate the keys.
    pub fn generate(&self, seed1: u8, seed2: u8, seed3: u32) -> ScramblerKeys {
        let neg_seed_1 = seed1;
        let neg_seed_2 = seed2;
        let neg_seed_3 = seed3;

        ScramblerKeys {
            keys: [
                self.derive(0, neg_seed_1, neg_seed_2, neg_seed_3),
                self.derive(1, neg_seed_1, neg_seed_2, neg_seed_3),
                self.derive(2, neg_seed_1, neg_seed_2, neg_seed_3),
            ],
            opcode_key_table: self.opcode_key_table.clone(),
        }
    }
}

/// Holds the keys generated by `ScramblerKeyGenerator`.
#[derive(Debug, Clone)]
pub struct ScramblerKeys {
    keys: [u8; 3],
    // TODO: maybe move somewhere else?
    opcode_key_table: Vec<i32>,
}

impl ScramblerKeys {
    /// Fetches the required base key for the given opcode.
    pub fn get_base_key(&self, opcode: u16) -> u8 {
        self.keys[(opcode % 3) as usize]
    }

    /// Fetches the opcode-based key from the table. This changes every patch.
    pub fn get_opcode_based_key(&self, opcode: u16) -> i32 {
        assert_eq!(self.opcode_key_table.len(), 51);
        let base_key = self.get_base_key(opcode);
        let index = (opcode as usize + base_key as usize) % self.opcode_key_table.len();
        self.opcode_key_table[index]
    }
}

pub unsafe fn unscramble_add<T: Copy + Sized>(data: &mut [u8], offset: usize, key: T)
where
    Wrapping<T>: std::ops::Add<Wrapping<T>, Output = Wrapping<T>>,
{
    unsafe {
        let ptr = data.as_mut_ptr().add(offset);

        let ptr_casted = ptr as *mut T;
        let wrapped_key = Wrapping(key);
        let wrapped_value = Wrapping(*ptr_casted);

        *ptr_casted = (wrapped_value + wrapped_key).0;
    }
}

pub unsafe fn unscramble_xor<T: Copy + Sized>(data: &mut [u8], offset: usize, key: T)
where
    Wrapping<T>: std::ops::BitXor<Wrapping<T>, Output = Wrapping<T>>,
{
    unsafe {
        let ptr = data.as_mut_ptr().add(offset);

        let ptr_casted = ptr as *mut T;
        let wrapped_key = Wrapping(key);
        let wrapped_value = Wrapping(*ptr_casted);

        *ptr_casted = (wrapped_value ^ wrapped_key).0;
    }
}

/// Scrambles the packet in just the right ways.
/// Not the greatest thing I ever implemented, it just copies what Unscrambler does. There might be a better way of doing this.
pub fn scramble_packet(opcode_name: &str, base_key: u8, opcode_based_key: i32, data: &mut [u8]) {
    unsafe {
        match opcode_name {
            "PlayerSpawn" => {
                // content id
                unscramble_add::<u64>(data, 24, base_key as u64);
                // home world
                unscramble_add::<u16>(data, 36, base_key as u16);
                // current world
                unscramble_add::<u16>(data, 38, base_key as u16);

                // name
                let name_offset = 610;
                for i in 0..CHAR_NAME_MAX_LENGTH {
                    unscramble_add::<u8>(data, name_offset + i, base_key);
                }

                // equipment
                let equip_offset = 556;
                let int_key_to_use = base_key as u32 + opcode_based_key as u32;
                for i in 0..10 {
                    let offset = equip_offset + i * std::mem::size_of::<u32>();
                    unscramble_xor::<u32>(data, offset, int_key_to_use);
                }
            }
            "NpcSpawn" => {
                // TODO: note what these fields are and upstream said comments
                unscramble_add::<u32>(data, 80, base_key as u32);
                unscramble_add::<u32>(data, 84, base_key as u32);
                unscramble_add::<u32>(data, 88, base_key as u32);
                unscramble_add::<u32>(data, 96, base_key as u32);
                unscramble_add::<u32>(data, 100, base_key as u32);

                unscramble_xor::<u32>(data, 108, opcode_based_key as u32);

                // ops?
                let op_offset = 168;
                for i in 0..30 {
                    let offset = op_offset + i * 22;
                    unscramble_add::<u16>(data, offset, base_key as u16);
                }
            }
            "Equip" => {
                let op_offset = 36;
                let int_key_to_use = base_key as u32 + opcode_based_key as u32;
                for i in 0..10 {
                    let offset = op_offset + i * std::mem::size_of::<u32>();
                    unscramble_xor::<u32>(data, offset, int_key_to_use);
                }
            }
            "StatusEffectList" => {
                let op_offset = 36;
                for i in 0..30 {
                    let offset = op_offset + i * 12;
                    unscramble_add::<u16>(data, offset, base_key as u16);
                }
            }
            "StatusEffectList3" => {
                let op_offset = 16;
                for i in 0..30 {
                    let offset = op_offset + i * 12;
                    unscramble_add::<u16>(data, offset, base_key as u16);
                }
            }
            _ => {}
        }
    }
}
