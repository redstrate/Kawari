//! Obfuscation-related structures and procedures. This is based on the ever fantastic work of Perchbird and his Unscrambler: https://github.com/perchbirdd/Unscrambler
//! This is simply a Rust-reimplementation of Unscrambler.

/// Constant to enable packet obfuscation. Changes every patch.
pub const OBFUSCATION_ENABLED_MODE: u8 = 118;

/// Generates the necessary keys from three seeds.
pub struct ScramblerKeyGenerator {
    table0: &'static [i32],
    table1: &'static [i32],
    table2: &'static [i32],
    mid_table: &'static [u8],
    day_table: &'static [u8],
    table_radixes: &'static [i32],
    table_max: &'static [i32],
}

impl Default for ScramblerKeyGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl ScramblerKeyGenerator {
    pub fn new() -> Self {
        // Technically unsafe, but Unscrambler's tables should be correct anyway
        unsafe {
            Self {
                table0: std::mem::transmute::<&[u8], &[i32]>(include_bytes!(
                    "../../resources/table0.bin"
                )),
                table1: std::mem::transmute::<&[u8], &[i32]>(include_bytes!(
                    "../../resources/table1.bin"
                )),
                table2: std::mem::transmute::<&[u8], &[i32]>(include_bytes!(
                    "../../resources/table2.bin"
                )),
                mid_table: include_bytes!("../../resources/midtable.bin"),
                day_table: include_bytes!("../../resources/daytable.bin"),

                // TODO: is it possible to calculate these automatically?
                table_radixes: &[93, 94, 113],
                table_max: &[219, 187, 113],
            }
        }
    }

    fn derive(&self, set: u8, n_seed_1: u8, n_seed_2: u8, epoch: u32) -> u8 {
        // FIXME: so many probably unnecessary casts here

        let mid_index = 8 * (n_seed_1 as usize % (self.mid_table.len() / 8));
        let mid_table_value = self.mid_table[4 + mid_index];
        let mut mid_bytes = [0u8; 4];
        mid_bytes.copy_from_slice(&self.mid_table[mid_index..mid_index + 4]);
        let mid_value = u32::from_le_bytes(mid_bytes);

        let epoch_days = 3 * (epoch as usize / 60 / 60 / 24);
        let day_table_index = 4 * (epoch_days % (self.day_table.len() / 4));
        let day_table_value = self.day_table[day_table_index];

        let set_radix = self.table_radixes[set as usize];
        let set_max = self.table_max[set as usize];
        let table_index = (set_radix * (n_seed_2 as i32 % set_max)) as usize
            + mid_value as usize * n_seed_1 as usize % set_radix as usize;
        let set_result = match set {
            0 => self.table0[table_index],
            1 => self.table1[table_index],
            2 => self.table2[table_index],
            _ => 0,
        };

        (n_seed_1 as i32 + mid_table_value as i32 + day_table_value as i32 + set_result) as u8
    }

    /// Generates keys for scrambling or unscrambling packets. The callee must keep track of their seeds, we only generate the keys.
    pub fn generate(&self, seed1: u8, seed2: u8, seed3: u32) -> ScramblerKeys {
        let neg_seed_1 = seed1;
        let neg_seed_2 = seed2;
        let neg_seed_3 = seed3;

        ScramblerKeys {
            keys: [
                self.derive(0, neg_seed_1, neg_seed_2, neg_seed_3),
                self.derive(1, neg_seed_1, neg_seed_2, neg_seed_3),
                self.derive(2, neg_seed_1, neg_seed_2, neg_seed_3),
            ],
        }
    }
}

/// Holds the keys generated by `ScramblerKeyGenerator`.
#[derive(Debug, Clone)]
pub struct ScramblerKeys {
    keys: [u8; 3],
}

impl ScramblerKeys {
    /// Fetches the required base key for the given opcode.
    pub fn get_base_key(&self, opcode: u16) -> u8 {
        self.keys[(opcode % 3) as usize]
    }
}

/// Scrambles the packet in just the right ways.
/// Not the greatest thing I ever implemented, it just copies what Unscrambler does. There might be a better way of doing this.
pub fn scramble_packet(opcode_name: &str, base_key: u8, data: &mut [u8]) {
    // NOTE: All offsets begin after the IPC segment header

    unsafe {
        match opcode_name {
            "PlayerSpawn" => {
                // content id
                *std::mem::transmute::<&mut [u8; 8], &mut u64>(
                    &mut data[24..32].try_into().unwrap(),
                ) += base_key as u64;
                // home world
                *std::mem::transmute::<&mut [u8; 2], &mut u16>(
                    &mut data[36..38].try_into().unwrap(),
                ) += base_key as u16;
                // current world
                *std::mem::transmute::<&mut [u8; 2], &mut u16>(
                    &mut data[38..40].try_into().unwrap(),
                ) += base_key as u16;

                // name
                let name_offset = 610;
                for i in 0..32 {
                    data[(name_offset + i) as usize] =
                        data[(name_offset + i) as usize].wrapping_add(base_key);
                }

                // equipment
                let equip_offset = 556;
                let int_key_to_use = base_key as u32 + 118426275;
                for i in 0..10 {
                    let offset = equip_offset + i * 4;
                    *std::mem::transmute::<&mut [u8; 4], &mut u32>(
                        &mut data[offset as usize..offset as usize + 4]
                            .try_into()
                            .unwrap(),
                    ) ^= int_key_to_use;
                }
            }
            "NpcSpawn" => {
                // TODO: note what these fields are
                *std::mem::transmute::<&mut [u8; 4], &mut u32>(
                    &mut data[80..84].try_into().unwrap(),
                ) += base_key as u32;
                *std::mem::transmute::<&mut [u8; 4], &mut u32>(
                    &mut data[84..88].try_into().unwrap(),
                ) += base_key as u32;
                *std::mem::transmute::<&mut [u8; 4], &mut u32>(
                    &mut data[88..92].try_into().unwrap(),
                ) += base_key as u32;
                *std::mem::transmute::<&mut [u8; 4], &mut u32>(
                    &mut data[96..100].try_into().unwrap(),
                ) += base_key as u32;
                *std::mem::transmute::<&mut [u8; 4], &mut u32>(
                    &mut data[100..104].try_into().unwrap(),
                ) += base_key as u32;
                let weird_const = 0xF1E2D9C8;
                *std::mem::transmute::<&mut [u8; 4], &mut u32>(
                    &mut data[108..112].try_into().unwrap(),
                ) ^= weird_const;

                // ops?
                /*let op_offset = 168;
                for i in 0..30 {
                    let offset = op_offset + i * 22;
                    *std::mem::transmute::<&mut [u8; 2], &mut u16>(&mut data[offset as usize..offset as usize + 2].try_into().unwrap()) += base_key as u16;
                }*/
            }
            "Equip" => {
                let op_offset = 36;
                let int_key_to_use = base_key as i32 - 863169860;
                for i in 0..10 {
                    let offset = op_offset + i * 4;
                    *std::mem::transmute::<&mut [u8; 4], &mut i32>(
                        &mut data[offset as usize..offset as usize + 4]
                            .try_into()
                            .unwrap(),
                    ) ^= int_key_to_use;
                }
            }
            _ => {}
        }
    }
}
