use std::{collections::HashMap, path::PathBuf};

use serde_json::Value;

fn main() {
    // Add link search directory for Oodle
    println!(
        "cargo:rustc-link-search={}/../oodle",
        env!("CARGO_MANIFEST_DIR")
    );

    // Generate IPC opcodes
    {
        let mut d = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        d.push("../resources/data/opcodes.json");

        println!("cargo::rerun-if-changed={}", d.to_str().unwrap());

        let mut output_str =
            "//!This file is automatically generated from `resources/data/opcodes.json`!\nuse binrw::binrw;\nuse crate::packet::PredefinedOpcode;\n".to_string();

        let opcodes_buffer = std::fs::read_to_string(d).unwrap();
        let json: Value = serde_json::from_str(&opcodes_buffer).unwrap();
        for element in json.as_object().unwrap() {
            let key = element.0;
            let opcodes = element.1.as_array().unwrap();
            let mut seen_opcodes = Vec::new();

            // beginning
            output_str.push_str("#[binrw]\n");
            output_str.push_str("#[derive(Clone, PartialEq, Debug)]\n");
            output_str.push_str(&format!("pub enum {key} {{\n"));

            for opcode in opcodes {
                let opcode = opcode.as_object().unwrap();
                let name = opcode.get("name").unwrap().as_str().unwrap();
                if let Some(comment) = opcode.get("comment").unwrap_or_default().as_str() {
                    output_str.push_str(&format!("/// {comment}\n"));
                }

                let opcode = opcode.get("opcode").unwrap().as_number().unwrap();

                if !seen_opcodes.contains(&opcode) {
                    seen_opcodes.push(opcode);
                } else {
                    panic!("{name} has the same opcode as another, this isn't possible!");
                }

                output_str.push_str(&format!("#[brw(magic = {opcode}u16)]\n"));
                output_str.push_str(&format!("{name},\n"));
            }

            output_str.push_str("Unknown(u16),\n");

            // end
            output_str.push_str("}\n\n");

            output_str.push_str(&format!("impl Default for {key} {{\n"));
            output_str.push_str("fn default () -> Self {\n");
            output_str.push_str("Self::Unknown(0)\n");
            output_str.push_str("}\n");
            output_str.push_str("}\n");

            output_str.push_str(&format!("impl PredefinedOpcode for {key} {{\n"));

            // sizes
            output_str.push_str("fn calc_size(&self) -> u32 {\n");
            output_str.push_str("match self {\n");

            for opcode in opcodes {
                let opcode = opcode.as_object().unwrap();
                let name = opcode.get("name").unwrap().as_str().unwrap();
                let size = opcode.get("size").unwrap().as_number().unwrap();

                output_str.push_str(&format!("{key}::{name} => {size},\n"));
            }

            output_str.push_str(&format!("{key}::Unknown(_) => 0,\n"));

            output_str.push_str("}\n\n");
            output_str.push_str("}\n\n");

            // names
            output_str.push_str("fn get_name(&self) -> &'static str {\n");
            output_str.push_str("match self {\n");

            for opcode in opcodes {
                let opcode = opcode.as_object().unwrap();
                let name = opcode.get("name").unwrap().as_str().unwrap();

                output_str.push_str(&format!("{key}::{name} => \"{name}\",\n"));
            }

            output_str.push_str(&format!("{key}::Unknown(_) => \"Unknown\",\n"));

            output_str.push_str("}\n\n");
            output_str.push_str("}\n\n");

            // opcodes
            output_str.push_str("/// Returns the integer opcode.\n");
            output_str.push_str("fn get_opcode(&self) -> u16 {\n");
            output_str.push_str("match self {\n");

            for opcode in opcodes {
                let opcode = opcode.as_object().unwrap();
                let name = opcode.get("name").unwrap().as_str().unwrap();
                let opcode = opcode.get("opcode").unwrap().as_number().unwrap();

                output_str.push_str(&format!("{key}::{name} => {opcode},\n"));
            }

            output_str.push_str(&format!("{key}::Unknown(opcode) => *opcode,\n"));

            output_str.push_str("}\n\n");
            output_str.push_str("}\n\n");

            // comments
            output_str.push_str("fn get_comment(&self) -> Option<&'static str> {\n");
            output_str.push_str("match self {\n");

            for opcode in opcodes {
                let opcode = opcode.as_object().unwrap();
                let name = opcode.get("name").unwrap().as_str().unwrap();

                if let Some(comment) = opcode.get("comment").unwrap_or_default().as_str() {
                    output_str.push_str(&format!("{key}::{name} => Some(\"{comment}\"),\n"));
                }
            }

            output_str.push_str("_ => None,\n");

            output_str.push_str("}\n\n");
            output_str.push_str("}\n\n");

            // end impl
            output_str.push_str("}\n\n");
        }

        std::fs::write("src/opcodes.rs", output_str).expect("Failed to write opcodes file!");
    }

    // Generate constants
    {
        let mut d = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        d.push("../resources/data/constants.yml");

        println!("cargo::rerun-if-changed={}", d.to_str().unwrap());

        let mut type_map: HashMap<&str, &str> = HashMap::new();
        type_map.insert("LOBBY_GAME_VERSION", "u32");
        type_map.insert("BASE_INVENTORY_ACTION", "u32");
        type_map.insert("OBFUSCATION_ENABLED_MODE", "u8");
        type_map.insert("OBFUSCATION_TABLE_RADIXES", "[i32; 3]");
        type_map.insert("OBFUSCATION_TABLE_MAX", "[i32; 3]");
        type_map.insert("SUPPORTED_BOOT_VERSION", "&str");
        type_map.insert("SUPPORTED_GAME_VERSION", "&str");

        let mut output_str =
            "//! This file is automatically generated from `resources/data/constants.yml`!\n"
                .to_string();

        let constants_buffer = std::fs::read_to_string(d).unwrap();
        let yml: Value = serde_yaml_ng::from_str(&constants_buffer).unwrap();
        for (key, value) in yml.as_object().unwrap() {
            let mut value_type = type_map
                .get(key.clone().as_str())
                .unwrap_or(&"usize")
                .to_string();

            // This is special because it also defines how many expansions we support.
            if key == "SUPPORTED_EXPAC_VERSIONS" {
                let max_expansions = value.as_array().unwrap().len();
                output_str.push_str(&format!(
                    "pub const MAX_EXPANSION: usize = {max_expansions};\n"
                ));
                value_type = format!("[&str; {max_expansions}]");
            }

            output_str.push_str(&format!("pub const {key}: {value_type} = {value};\n"));
        }

        std::fs::write("src/constants.rs", output_str).expect("Failed to write constants file!");
    }
}
